// statsDisplay.js

export class StatsDisplay {
    constructor(containerId = 'performance-stats') {
      this.stats = {
        latency: 0,
        tokensPerSecond: 0,
        chunkCount: 0,
        partialTokens: 0,
        activeConnections: 0,
        promptTokens: 0,
        completionTokens: 0,
        reasoningTokens: 0,
        totalTokens: 0,
        timeToResponse: 0,
        timeBetweenTokens: 0
      };
    
      this.container = document.getElementById(containerId);
      if (!this.container) {
        console.error(`StatsDisplay container not found: #${containerId}`);
        return;
      }
      
      // Initialize the stats toggle functionality
      this.initStatsToggle();
  
      // Define default values for prompt/completion/reasoning tokens
      const usage = {
        promptTokens: 0,
        completionTokens: 0,
        reasoningTokens: 0
      };
      usage.totalTokens = usage.promptTokens + usage.completionTokens + usage.reasoningTokens;

      // Update stats display
      if (window.statsDisplay) {
        window.statsDisplay.updateStats(usage);
      }

      // Also update the mobile token usage if needed
      // Provide a no-op function if not defined
      function syncMobileStats(usage) {
        // Placeholder, no-op or custom mobile stats logic
        // console.debug("syncMobileStats called with usage:", usage);
      }
      // Add throttling variables
      this.lastUpdateTime = 0;
      this.updateThrottleMs = 1000; // Update UI every second for better responsiveness
      this.pendingUpdate = false;

      this.initDisplay();
      this.startConnectionTracking();
    }
  
    initDisplay() {
      this.container.innerHTML = `
        <div class="stats-grid">
          <div class="stat-item">
            <span class="stat-label">Latency</span>
            <span class="stat-value" id="latency-value">0ms</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Speed</span>
            <span class="stat-value" id="tokens-value">0 t/s</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Connections</span>
            <span class="stat-value" id="connections-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Total Tokens</span>
            <span class="stat-value" id="total-tokens-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Processed Prompt Tokens</span>
            <span class="info-icon" title="Number of input tokens processed by the model. Matches Azure Monitor's 'Processed Prompt Tokens'.">?</span>
            <span class="stat-value" id="prompt-tokens-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Generated Completion Tokens</span>
            <span class="info-icon" title="Number of output tokens generated by the model. Matches Azure Monitor's 'Generated Completion Tokens'.">?</span>
            <span class="stat-value" id="completion-tokens-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Reasoning</span>
            <span class="stat-value" id="reasoning-tokens-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Time to Response</span>
            <span class="stat-value" id="time-to-response">0ms</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Token Interval</span>
            <span class="stat-value" id="time-between-tokens">0ms</span>
          </div>
        </div>
      `;
    }
  
    startConnectionTracking() {
      // Ping endpoint every 60s, with simple failure backoff and optional disable
      const DISABLE_CONNECTION_TRACKING = window.DISABLE_CONNECTION_TRACKING === true;
      const MAX_FAILED_ATTEMPTS = 3;
      let failedAttempts = 0;
  
      if (!DISABLE_CONNECTION_TRACKING) {
        const fetchConnections = async () => {
          try {
            try {
              const response = await fetch('/api/model-stats/connections');
              if (!response.ok) {
                console.warn(`Connection stats request failed with HTTP ${response.status}`);
                return; // optionally show a notification here
              }
              const data = await response.json();
              if (data.connections && data.connections.concurrent_connections !== undefined) {
                this.stats.activeConnections = data.connections.concurrent_connections;
              } else if (data.active_connections !== undefined) {
                // Fallback for backward compatibility
                this.stats.activeConnections = data.active_connections;
              } else {
                this.stats.activeConnections = 0;
              }
            } catch (err) {
              console.warn('Connection stats request threw an error:', err);
              // optionally show a notification
              return;
            }
            failedAttempts = 0;
          } catch (e) {
            failedAttempts++;
            if (window.DEBUG_MODE) {
              console.error('Failed to fetch active connections', e);
            }
            this.stats.activeConnections = 0;
            // If too many consecutive failures, skip further polls
            if (failedAttempts >= MAX_FAILED_ATTEMPTS) {
              if (window.DEBUG_MODE) {
                console.warn('Too many consecutive connection fetch failures, disabling tracking.');
              }
              return;
            }
          }
          this.render();
          // Reschedule after 60s if not disabled
          if (failedAttempts < MAX_FAILED_ATTEMPTS) {
            setTimeout(fetchConnections, 60000);
          }
        };
        fetchConnections();
      }
    }
  
    initStatsToggle() {
      // Set up the mobile stats toggle functionality
      const statsToggle = document.getElementById('mobile-stats-toggle');
      const statsPanel = document.getElementById('mobile-stats-panel');
      
      if (statsToggle && statsPanel) {
        console.log('StatsDisplay: Setting up mobile stats toggle');
        
        statsToggle.addEventListener('click', function() {
          console.log('Stats toggle clicked from StatsDisplay');
          statsPanel.classList.toggle('hidden');
        });
      }
    }
    
    render() {
      if (!this.container) return;
  
      // Render latency - only update if value is defined and not 0
      if (this.stats.latency) {
        this.container.querySelector('#latency-value').textContent =
          `${this.stats.latency}ms`;
      }

      // Handle optional chunk count and partial tokens (if elements exist)
      const chunkEl = this.container.querySelector('#chunks-value');
      const partialTokensEl = this.container.querySelector('#partial-tokens-value');
      if (chunkEl && this.stats.chunkCount !== undefined) chunkEl.textContent = this.stats.chunkCount;
      if (partialTokensEl && this.stats.partialTokens !== undefined) partialTokensEl.textContent = this.stats.partialTokens;
  
      // Show tokensPerSecond as one decimal place, e.g. "12.3 t/s"
      const tpsEl = this.container.querySelector('#tokens-value');
      const tps = this.stats.tokensPerSecond || 0;
      tpsEl.textContent = `${tps.toFixed(1)} t/s`;

      // Add color coding for token speed
      if (tps > 100) {
        tpsEl.classList.add('text-red-500');
        tpsEl.classList.remove('text-yellow-500');
      } else if (tps > 50) {
        tpsEl.classList.add('text-yellow-500');
        tpsEl.classList.remove('text-red-500');
      } else {
        tpsEl.classList.remove('text-red-500', 'text-yellow-500');
      }
  
      // Update active connections (only if value exists)
      if (this.stats.activeConnections !== undefined) {
        this.container.querySelector('#connections-value').textContent =
          this.stats.activeConnections;
      }

      // Update timing metrics (only if values exist)
      if (this.stats.timeToResponse !== undefined) {
        this.container.querySelector('#time-to-response').textContent =
          `${(this.stats.timeToResponse || 0).toFixed(0)}ms`;
      }
      if (this.stats.timeBetweenTokens !== undefined) {
        this.container.querySelector('#time-between-tokens').textContent =
          `${(this.stats.timeBetweenTokens || 0).toFixed(0)}ms`;
      }

      // Always update token counts, even if 0
      this.container.querySelector('#prompt-tokens-value').textContent =
        new Intl.NumberFormat().format(this.stats.promptTokens || 0);
      this.container.querySelector('#completion-tokens-value').textContent =
        new Intl.NumberFormat().format(this.stats.completionTokens || 0);
      this.container.querySelector('#reasoning-tokens-value').textContent =
        new Intl.NumberFormat().format(this.stats.reasoningTokens || 0);
  
      // Calculate and display total tokens
      const totalTokens = this.stats.totalTokens || 
        (this.stats.promptTokens || 0) + (this.stats.completionTokens || 0);
      
      this.container.querySelector('#total-tokens-value').textContent =
        new Intl.NumberFormat('en', { 
          notation: totalTokens > 999999 ? 'compact' : 'standard',
          maximumFractionDigits: 1 
        }).format(totalTokens);
        
      // Update cached tokens if that element exists
      const cachedTokensEl = this.container.querySelector('#cached-tokens-value');
      if (cachedTokensEl && this.stats.cachedTokens !== undefined) {
        cachedTokensEl.textContent = new Intl.NumberFormat().format(this.stats.cachedTokens);
      }
    }
  
    triggerAnimations() {
      // Brief highlight animation on updated values
      this.container.querySelectorAll('.stat-value').forEach(el => {
        el.classList.add('stat-update-flash');
        setTimeout(() => el.classList.remove('stat-update-flash'), 300);
      });
    }
    
    updateStats(newStats) {
      // Merge the new stats into our existing stats object
      Object.assign(this.stats, newStats);
      
      // Throttle the UI updates
      const now = Date.now();
      if (now - this.lastUpdateTime >= this.updateThrottleMs) {
        this.render();
        this.triggerAnimations();
        this.lastUpdateTime = now;
        this.pendingUpdate = false;
      } else if (!this.pendingUpdate) {
        // Schedule an update for later if we haven't already
        this.pendingUpdate = true;
        setTimeout(() => {
          if (this.pendingUpdate) {
            this.render();
            this.triggerAnimations();
            this.lastUpdateTime = Date.now();
            this.pendingUpdate = false;
          }
        }, this.updateThrottleMs);
      }
    }
  }
