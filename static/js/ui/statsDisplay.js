// statsDisplay.js

// This file provides a StatsDisplay class which retrieves and displays usage and performance metrics.
// We'll rewrite the content to ensure no invalid characters or unterminated template literals.

export class StatsDisplay {
  constructor(containerId = 'performance-stats') {
    this.stats = {
      latency: 0,
      tokensPerSecond: 0,
      chunkCount: 0,
      partialTokens: 0,
      activeConnections: 0,
      promptTokens: 0,
      completionTokens: 0,
      reasoningTokens: 0,
      totalTokens: 0,
      timeToResponse: 0,
      timeBetweenTokens: 0
    };

    this.container = document.getElementById(containerId);
    if (!this.container) {
      console.error(`StatsDisplay container not found: #${containerId}`);
      return;
    }

    // Initialize stats toggle
    this.initStatsToggle();

    // Define default usage
    const usage = {
      promptTokens: 0,
      completionTokens: 0,
      reasoningTokens: 0
    };
    usage.totalTokens = usage.promptTokens + usage.completionTokens + usage.reasoningTokens;

    // If a global statsDisplay is used, update it
    if (window.statsDisplay) {
      window.statsDisplay.updateStats(usage);
    }

    // Throttling variables
    this.lastUpdateTime = 0;
    this.updateThrottleMs = 1000; 
    this.pendingUpdate = false;

    this.initDisplay();
    this.startConnectionTracking();
  }

  initDisplay() {
    this.container.innerHTML = `
      <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-label">Latency</span>
          <span class="stat-value" id="latency-value">0ms</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Speed</span>
          <span class="stat-value" id="tokens-value">0 t/s</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Connections</span>
          <span class="stat-value" id="connections-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Total Tokens</span>
          <span class="stat-value" id="total-tokens-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Processed Prompt Tokens</span>
          <span class="info-icon" title="Number of input tokens processed by the model.">?</span>
          <span class="stat-value" id="prompt-tokens-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Generated Completion Tokens</span>
          <span class="info-icon" title="Number of output tokens generated by the model.">?</span>
          <span class="stat-value" id="completion-tokens-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Reasoning</span>
          <span class="stat-value" id="reasoning-tokens-value">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Time to Response</span>
          <span class="stat-value" id="time-to-response">0ms</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Token Interval</span>
          <span class="stat-value" id="time-between-tokens">0ms</span>
        </div>
      </div>
    `;
  }

  startConnectionTracking() {
    const DISABLE_CONNECTION_TRACKING = window.DISABLE_CONNECTION_TRACKING === true;
    const MAX_FAILED_ATTEMPTS = 3;
    let failedAttempts = 0;

    if (!DISABLE_CONNECTION_TRACKING) {
      const fetchConnections = async () => {
        try {
          try {
            const response = await fetch('/api/model-stats/connections');
            if (!response.ok) {
              console.warn(`Connection stats request failed with HTTP ${response.status}`);
              return;
            }
            const data = await response.json();
            if (data.connections && data.connections.concurrent_connections !== undefined) {
              this.stats.activeConnections = data.connections.concurrent_connections;
            } else if (data.active_connections !== undefined) {
              this.stats.activeConnections = data.active_connections;
            } else {
              this.stats.activeConnections = 0;
            }
          } catch (err) {
            console.warn('Connection stats request error:', err);
            return;
          }
          failedAttempts = 0;
        } catch (e) {
          failedAttempts++;
          if (window.DEBUG_MODE) {
            console.error('Failed to fetch active connections', e);
          }
          this.stats.activeConnections = 0;
          if (failedAttempts >= MAX_FAILED_ATTEMPTS) {
            if (window.DEBUG_MODE) {
              console.warn('Too many connection fetch failures, disabling tracking.');
            }
            return;
          }
        }
        this.render();
        if (failedAttempts < MAX_FAILED_ATTEMPTS) {
          setTimeout(fetchConnections, 60000);
        }
      };
      fetchConnections();
    }
  }

  initStatsToggle() {
    const statsToggle = document.getElementById('mobile-stats-toggle');
    const statsPanel = document.getElementById('mobile-stats-panel');
    if (statsToggle && statsPanel) {
      statsToggle.addEventListener('click', () => {
        statsPanel.classList.toggle('hidden');
      });
    }
  }

  render() {
    if (!this.container) return;

    // Latency
    if (typeof this.stats.latency === 'number') {
      const latEl = this.container.querySelector('#latency-value');
      if (latEl) {
        latEl.textContent = `${this.stats.latency}ms`;
      }
    }

    // chunkCount, partialTokens
    const chunkEl = this.container.querySelector('#chunks-value');
    const partialTokensEl = this.container.querySelector('#partial-tokens-value');
    if (chunkEl && this.stats.chunkCount !== undefined) {
      chunkEl.textContent = this.stats.chunkCount;
    }
    if (partialTokensEl && this.stats.partialTokens !== undefined) {
      partialTokensEl.textContent = this.stats.partialTokens;
    }

    // tokens/s
    const tpsEl = this.container.querySelector('#tokens-value');
    const tps = this.stats.tokensPerSecond || 0;
    if (tpsEl) {
      tpsEl.textContent = `${tps.toFixed(1)} t/s`;
      if (tps > 100) {
        tpsEl.classList.add('text-red-500');
        tpsEl.classList.remove('text-yellow-500');
      } else if (tps > 50) {
        tpsEl.classList.add('text-yellow-500');
        tpsEl.classList.remove('text-red-500');
      } else {
        tpsEl.classList.remove('text-red-500', 'text-yellow-500');
      }
    }

    // Connections
    if (this.stats.activeConnections !== undefined) {
      const conEl = this.container.querySelector('#connections-value');
      if (conEl) {
        conEl.textContent = String(this.stats.activeConnections);
      }
    }

    // timeToResponse
    if (typeof this.stats.timeToResponse === 'number') {
      const ttrEl = this.container.querySelector('#time-to-response');
      if (ttrEl) {
        ttrEl.textContent = `${this.stats.timeToResponse.toFixed(0)}ms`;
      }
    }

    // timeBetweenTokens
    if (typeof this.stats.timeBetweenTokens === 'number') {
      const tbtEl = this.container.querySelector('#time-between-tokens');
      if (tbtEl) {
        tbtEl.textContent = `${this.stats.timeBetweenTokens.toFixed(0)}ms`;
      }
    }

    // prompt, completion, reasoning tokens
    const promptEl = this.container.querySelector('#prompt-tokens-value');
    if (promptEl) {
      promptEl.textContent = new Intl.NumberFormat().format(this.stats.promptTokens || 0);
    }
    const completionEl = this.container.querySelector('#completion-tokens-value');
    if (completionEl) {
      completionEl.textContent = new Intl.NumberFormat().format(this.stats.completionTokens || 0);
    }
    const reasoningEl = this.container.querySelector('#reasoning-tokens-value');
    if (reasoningEl) {
      reasoningEl.textContent = new Intl.NumberFormat().format(this.stats.reasoningTokens || 0);
    }

    // total tokens
    const totalTokens = this.stats.totalTokens || (this.stats.promptTokens + this.stats.completionTokens);
    const totalEl = this.container.querySelector('#total-tokens-value');
    if (totalEl) {
      totalEl.textContent = new Intl.NumberFormat('en', {
        notation: totalTokens > 999999 ? 'compact' : 'standard',
        maximumFractionDigits: 1
      }).format(totalTokens);
    }

    // If there's a cached-tokens-value in the DOM, update it
    const cachedEl = this.container.querySelector('#cached-tokens-value');
    if (cachedEl && this.stats.cachedTokens !== undefined) {
      cachedEl.textContent = new Intl.NumberFormat().format(this.stats.cachedTokens);
    }
  }

  triggerAnimations() {
    this.container.querySelectorAll('.stat-value').forEach(el => {
      el.classList.add('stat-update-flash');
      setTimeout(() => el.classList.remove('stat-update-flash'), 300);
    });
  }

  updateStats(newStats) {
    Object.assign(this.stats, newStats);
    const now = Date.now();
    if (now - this.lastUpdateTime >= this.updateThrottleMs) {
      this.render();
      this.triggerAnimations();
      this.lastUpdateTime = now;
      this.pendingUpdate = false;
    } else if (!this.pendingUpdate) {
      this.pendingUpdate = true;
      setTimeout(() => {
        if (this.pendingUpdate) {
          this.render();
          this.triggerAnimations();
          this.lastUpdateTime = Date.now();
          this.pendingUpdate = false;
        }
      }, this.updateThrottleMs);
    }
  }

  /**
   * Fetch session-level usage data from the backend
   * @param {string} sessionId 
   */
  async loadSessionStats(sessionId) {
    if (!sessionId) return;
    try {
      const response = await fetch(`/api/model-stats/session/${sessionId}`);
      if (!response.ok) {
        console.warn(`Failed to fetch session stats: ${response.status}`);
        return;
      }
      const data = await response.json();
      // data.stats is an object with per-model usage, we sum them
      if (data && data.stats) {
        let totalPrompt = 0;
        let totalCompletion = 0;
        let totalReasoning = 0;
        let totalTokens = 0;
        for (const modelName of Object.keys(data.stats)) {
          const s = data.stats[modelName];
          totalPrompt += s.prompt_tokens || 0;
          totalCompletion += s.completion_tokens || 0;
          totalReasoning += s.reasoning_tokens || 0;
          totalTokens += s.total_tokens || 0;
        }
        this.updateStats({
          promptTokens: totalPrompt,
          completionTokens: totalCompletion,
          reasoningTokens: totalReasoning,
          totalTokens: totalTokens
        });
      }
    } catch (err) {
      console.error('Error fetching session stats:', err);
    }
  }
}
